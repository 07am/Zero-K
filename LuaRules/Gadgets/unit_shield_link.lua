function gadget:GetInfo()	return {		name 	= "Shield Link",		desc	= "Nearby shields on the same ally team share charge to and from each other. Working Version",		author	= "lurker",		date	= "2009",		license	= "Public domain",		layer	= 0,		enabled	= true	--	loaded by default?	}endlocal version = 1.14-- CHANGELOG--	2009-5-24: CarRepairer: Added graphic lines to show links of shields (also shows links of enemies' visible shields, can remove if desired).--	2009-5-30: CarRepairer: Lups graphic lines, fix for 0.79.1 compatibility.--	2009-9-15: Licho: added simple fast graph lines----------------------------------------------------------------------------------------------------------------------------------------------------------------local spGetUnitPosition		= Spring.GetUnitPositionlocal spGetUnitDefID		= Spring.GetUnitDefIDlocal spGetUnitTeam			= Spring.GetUnitTeamlocal spGetUnitAllyTeam		= Spring.GetUnitAllyTeamlocal spGetUnitIsStunned	= Spring.GetUnitIsStunnedlocal spGetUnitIsActive		= Spring.GetUnitIsActivelocal spGetUnitShieldState	= Spring.GetUnitShieldStatelocal spSetUnitShieldState	= Spring.SetUnitShieldStatelocal spGetTeamInfo			= Spring.GetTeamInfoif gadgetHandler:IsSyncedCode() thenlocal shieldTeams = {}shieldConnections = {}local linkFirst = {	[UnitDefNames["shieldfelon"].id] = 4,	[UnitDefNames["core_spectre"].id] = 3, --aspis	[UnitDefNames["corjamt"].id] = 3, --aegis}function gadget:Initialize()	for _,unitID in ipairs(Spring.GetAllUnits()) do		local teamID = spGetUnitTeam(unitID)		local unitDefID = spGetUnitDefID(unitID)		gadget:UnitCreated(unitID, unitDefID, teamID)	endendfunction gadget:UnitCreated(unitID, unitDefID)	-- only count finished buildings	local stunned_or_inbuild, stunned, inbuild = spGetUnitIsStunned(unitID)	if stunned_or_inbuild ~= nil and inbuild then		return	end	local ud = UnitDefs[unitDefID]	if ud.shieldWeaponDef then		local shieldWep = WeaponDefs[ud.shieldWeaponDef]		local x,y,z = spGetUnitPosition(unitID)		local allyTeam = spGetUnitAllyTeam(unitID)		shieldTeams[allyTeam] = shieldTeams[allyTeam] or {}		local shieldUnit = {			shieldPower = shieldWep.shieldPower,			shieldRadius = shieldWep.shieldRadius,			shieldRegen = shieldWep.shieldPowerRegen,			shieldOn = true,			linkFirst = linkFirst[unitDefID],			link = {},		}		shieldTeams[allyTeam][unitID] = shieldUnit	endendfunction gadget:UnitFinished(unitID, unitDefID, unitTeam)	gadget:UnitCreated(unitID, unitDefID)endfunction gadget:UnitDestroyed(unitID, unitDefID)	local ud = UnitDefs[unitDefID]	local allyTeam = spGetUnitAllyTeam(unitID)	if ud.shieldWeaponDef and shieldTeams[allyTeam] then		local shieldUnit = shieldTeams[allyTeam][unitID]		shieldTeams[allyTeam][unitID] = nil		if shieldUnit then			shieldUnit.link[unitID] = nil		end	endendfunction gadget:UnitGiven(unitID, unitDefID, unitTeam, oldTeam)	local ud = UnitDefs[unitDefID]	local _,_,_,_,_,oldAllyTeam = spGetTeamInfo(oldTeam)	if ud.shieldWeaponDef then		local shieldUnit		if shieldTeams[oldAllyTeam] and shieldTeams[oldAllyTeam][unitID] then			shieldUnit = shieldTeams[oldAllyTeam][unitID]			shieldTeams[oldAllyTeam][unitID] = nil			shieldUnit.link[unitID] = nil			shieldUnit.link = {}		end					local allyTeam = spGetUnitAllyTeam(unitID)		shieldTeams[allyTeam] = shieldTeams[allyTeam] or {}		shieldTeams[allyTeam][unitID] = shieldUnit --Note: wont be problem when NIL because is always filled with new value when unit finish (ie: when unit captured before finish) 	endend-- check if working unit so it can be used for shield linklocal function linkable(unitID)	local stunned_or_inbuild, stunned, inbuild = spGetUnitIsStunned(unitID)	if stunned_or_inbuild or (Spring.GetUnitRulesParam(unitID, "disarmed") == 1) then		return false	end	local active = spGetUnitIsActive(unitID)	if active ~= nil then		return active	else		return true	endendlocal function AdjustLinks(allyTeam, unitList, updatePrioritized)        local sc = shieldConnections[allyTeam]		local cnt = #sc + 1		-- cache		local unitStat = {}		for ud1,shieldUnit1 in pairs(unitList) do			repeat --Is clever hax for making "break" behave like "continue"				if (not shieldUnit1.linkFirst) == updatePrioritized then break end --skip unprioritized/prioritized units				if unitStat[ud1] == nil then					unitStat[ud1] = linkable(ud1)				end				if not unitStat[ud1] then break end -- continue to next unit				for ud2,shieldUnit2 in pairs(unitList) do --iterate over all shield unit, find anyone that's in range.					if unitStat[ud2] == nil then						unitStat[ud2] = linkable(ud2)					end					if ((not shieldUnit1.linkFirst) or shieldUnit1.linkFirst > #shieldUnit1.neighbor)                        and shieldUnit1.link ~= shieldUnit2.link and unitStat[ud2] and shieldUnit1.valid and shieldUnit2.valid then --if new link isn't existing link, and if this unit is linkable, then: 						local xDiff = shieldUnit1.x - shieldUnit2.x						local zDiff = shieldUnit1.z - shieldUnit2.z						local yDiff = shieldUnit1.y - shieldUnit2.y						local sumRadius = shieldUnit1.shieldRadius + shieldUnit2.shieldRadius						if xDiff <= sumRadius and zDiff <= sumRadius and (xDiff*xDiff + yDiff*yDiff + zDiff*zDiff) < sumRadius*sumRadius then --if this unit is in range of old unit:															sc[cnt] = {ud1,ud2}							cnt = cnt + 1									shieldUnit1.neighbor[#shieldUnit1.neighbor + 1] = ud2							shieldUnit2.neighbor[#shieldUnit2.neighbor + 1] = ud1															for unitID,shieldUnit3 in pairs(shieldUnit2.link) do								shieldUnit1.link[unitID] = shieldUnit3 --copy content from new link to existing link								shieldUnit3.link = shieldUnit1.link --assign existing link to new unit							end							shieldUnit2.link = shieldUnit1.link --assign existing link to new unit						end					end				end -- for ud2			until true --exit repeat		end	-- for ud1endlocal function UpdateAllLinks()	shieldConnections = {}	_G.shieldConnections = shieldConnections	for allyTeam,unitList in pairs(shieldTeams) do		for unitID,shieldUnit in pairs(unitList) do			local x,y,z = spGetUnitPosition(unitID)			shieldUnit.link = {[unitID] = shieldUnit}			shieldUnit.x = x			shieldUnit.y = y			shieldUnit.z = z			shieldUnit.valid = x and y and z			shieldUnit.neighbor = {}		end        shieldConnections[allyTeam] = {}        AdjustLinks(allyTeam, unitList, true) --unit that is linked first (have most link)        AdjustLinks(allyTeam, unitList, false)	endendlocal RECHARGE_KOEF = 0.01function gadget:GameFrame(n)	if n%30 == 18 then UpdateAllLinks() end --update every 30 frame at the 18th frame		-- cache	local unitStat = {}	for allyTeam,unitList in pairs(shieldTeams) do		local processedLinks = {} --DO NOT USE PAIRS ON THIS		for unitID,shieldUnit in pairs(unitList) do			repeat --doesn't do loop but make "break" behave like "continue"				if not processedLinks[shieldUnit.link] then --check if this linked group have been processed before					processedLinks[shieldUnit.link] = true --mark this linked groupd as processed					-- only update working shields					if unitStat[unitID] == nil then						unitStat[unitID] = linkable(unitID)					end					if not unitStat[unitID] then 						break -- continue					end 					--==Distribution Method A: distribute to nearest neighbor					for unitID2,shieldUnit2 in pairs(shieldUnit.link) do						local charger_On,charger_charge = spGetUnitShieldState(unitID2, -1)						local charger_capacity = shieldUnit2.shieldPower						shieldUnit2.shieldOn = charger_On						if (charger_On) then							for i=1, #shieldUnit2.neighbor do								local unitID3 = shieldUnit2.neighbor[i]								local shieldUnit3 = shieldUnit.link[unitID3]								if shieldUnit3~= nil then --shield dead? (NOTE! neighbor list is not updated when unit die, its only updated in AdjustLinks(), however "shieldUnit.link[unitID]" is emptied upon death)									local chargee_On,chargee_charge = spGetUnitShieldState(unitID3, -1)									shieldUnit3.shieldOn = chargee_On									if (chargee_On) and (charger_charge>chargee_charge) then 										local chargee_capacity = shieldUnit3.shieldPower										local chargee_regen = shieldUnit3.shieldRegen										--charge flow is: based on the absolute difference in charge content,										--charge flow must:										--1)not be more than receiver's capacity, 										--2)not be more than donator's available charge,										--3)leave spaces for receiver to regen,										--charge flow is capable: to reverse flow when receiver have regen and is full,										local chargeFlow = math.min(RECHARGE_KOEF*(charger_charge-chargee_charge),charger_charge, chargee_capacity-chargee_regen-chargee_charge) --minimize positive flow										chargeFlow = math.max(chargeFlow, charger_charge - charger_capacity) --minimize negative flow										charger_charge = charger_charge - chargeFlow --deduct charge										spSetUnitShieldState(unitID3, -1, chargee_charge + chargeFlow)--add charge to receiver									end								end							end							spSetUnitShieldState(unitID2, -1, charger_charge)--deduct charge						end 					end					--[[== Distribution Method B: distribute to all linked shield based on total average					local totalCharge =	0					local linkUnits = 0					local udata = {}	-- unit data,	charge and chargeMax					for unitID2,shieldUnit2 in pairs(shieldUnit.link) do						local shieldOn,shieldCharge = spGetUnitShieldState(unitID2, -1)						shieldUnit.shieldOn = shieldOn						if (shieldOn) then 							udata[unitID2] = {								charge = shieldCharge,								chargeMax = shieldUnit2.shieldPower							}							totalCharge = totalCharge + shieldCharge							linkUnits = linkUnits + 1						end 					end					local avg = totalCharge / linkUnits	-- calculate average charge of netwrok 					local overflow = 0					local slack = 0 					for uid,d in pairs(udata) do	-- equalize all sheilds to average by 1% of their difference from average 						local newCharge = d.charge + (avg - d.charge) * RECHARGE_KOEF						if (newCharge > d.chargeMax) then 							overflow = overflow + newCharge - d.chargeMax							newCharge = d.chargeMax						else 							slack = slack + d.chargeMax - newCharge						end 						d.charge = newCharge						spSetUnitShieldState(uid, -1, newCharge)					end							if overflow > 0 and slack > 0 then	-- if there was overflow (above max charge) and	there is still some unused space for charge, transfer it there 						for uid,d in pairs(udata) do							if (d.charge < d.chargeMax) then 								local newCharge = d.charge + overflow * (d.chargeMax - d.charge) / slack 								spSetUnitShieldState(uid, -1, newCharge)							end 						end					end 					--==]]				end			until true --exit repeat		end	endend------------------------------------------------------------------------------------------------------------------------------------------------------------------UNSYNCEDelse----------------------------------------------------------------------------------------------------------------------------------------------------------------local glVertex = gl.Vertexlocal glColor = gl.Colorlocal glBeginEnd = gl.BeginEndlocal glPushAttrib = gl.PushAttriblocal glLineWidth = gl.LineWidthlocal glDepthTest = gl.DepthTestlocal glPopAttrib = gl.PopAttriblocal GL_LINE_BITS = GL.LINE_BITSlocal GL_LINES     = GL.LINESlocal spGetMyAllyTeamID    = Spring.GetMyAllyTeamIDlocal spGetSpectatingState = Spring.GetSpectatingStatelocal spIsUnitInView       = Spring.IsUnitInViewlocal spValidUnitID        = Spring.ValidUnitID----------------------------------------------------------------------------------------------------------------------------------------------------------------function gadget:Initialize()endlocal function DrawFunc()	myAllyID = spGetMyAllyTeamID()	local spec, fullview = spGetSpectatingState()	spec = spec or fullview		for allyID, connections in spairs(SYNCED.shieldConnections) do		for _,con in sipairs(connections) do			local u1 = con[1]			local u2 = con[2]						local l1			local l2						if (spec or allyID == myAllyID) then				l1 = spIsUnitInView(u1)				l2 = spIsUnitInView(u2)			end				if ((l1 or l2) and (spValidUnitID(u1) and spValidUnitID(u2))) then				local _,_,_,x1, y1, z1 = spGetUnitPosition(u1, true)				local _,_,_,x2, y2, z2 = spGetUnitPosition(u2, true)				glVertex(x1, y1, z1)				glVertex(x2, y2, z2)			end		end	endend 	function gadget:DrawWorld()	if SYNCED.shieldConnections and snext(SYNCED.shieldConnections) then		glPushAttrib(GL_LINE_BITS)			glDepthTest(true)		glColor(1,0,1,math.random()*0.3+0.2)		glLineWidth(1)		glBeginEnd(GL_LINES, DrawFunc)			glDepthTest(false)		glColor(1,1,1,1)			glPopAttrib()	endend----------------------------------------------------------------------------------------------------------------------------------------------------------------end----------------------------------------------------------------------------------------------------------------------------------------------------------------